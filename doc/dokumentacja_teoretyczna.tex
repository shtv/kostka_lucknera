\documentclass[12pt]{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{hyphenat}
\usepackage{indentfirst}

\hypersetup{
	pdfinfo={
		Title = {Dokumentacja teoretyczna},
		Subject = {Dokumentacja teoretyczna},
		Author = {Paweł Baran, Andrzej Legucki},
		Keywords = {kostka, dokumentacja, teoretyczna}
	}
}

\title{
%\Huge{
%Teoria Algorytmów i Obliczeń
%}
\Huge{
%Laboratoria
Zima 2010 - kostka
} \\[0.5em]
\LARGE{
Dokumentacja teoretyczna
}
}

\author{
	Paweł Baran \and Andrzej Legucki
}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage
\section{Wstęp}
Niniejsza dokumentacja powstała w ramach pierwszego etapu laboratoriów
z~przedmiotu Teoria Algorytmów i Obliczeń. W niniejszym dokumencie
przedstawiamy opis algorytmu dokładnego oraz opisy dwu algorytmów
aproksymujących do zadania. Problemem jest ułożenie największego
pełnego prostopadłościanu z klocków. Pojedynczym zadaniem problemu jest
ułożenie pełnego prostopadłościanu z zadanego zestawu klocków.
Rozwiązaniem zadania jest sekwencja ruchów klocków należących do zestawu
z zadania.

Oprócz algorytmów przedstawione zostały opisy struktur danych potrzebnych
do funkcjonowania podanych algorytmów. Opis struktur danych ułatwi ich
obsługę w zakresie zapisu zestawu klocków i zapisu sekwencji ruchów.
Pierwszy zapis służy do zapisania danych wejściowych, drugi -- do zapisania
wyniku danego zadania sporządzonego przez zadany algorytm.

\section{Algorytm dokładny}

\section{Algorytmy aproksymacyjne}

\subsection{Algorytm klonowania}
Pierwszy z~algorytmów aproksymacyjnych jest autorstwa Pawła Baran.
W~niniejszym podrozdziale zostanie podany jego opis, pseudokod, koszty oraz
podsumowanie, w~którym przedstawione zostaną wady i~zalety algorytmu.

Algorytm składa się z~kilku kroków:
\begin{enumerate}
	\item grupowanie klocków,
	\item sprawdzenie kilku wybranych proporcji,
	\item wybranie optymalnego i~klonowanie.
\end{enumerate}

Algorytm stara się ułożyć prostopadłościan z~klocków, które mają swoje
kopie. Jeśli nie jest możliwe ułożenie z~klocków powtarzających się,
algorytm wykorzystuje wszystkie dostępne klocki, czyli w~najgorszym
przypadku zachowuje się jak algorytm dokładny, nie zmieniając kosztów
obliczeń w~stosunku do niego.

\subsubsection{Etap 1. Grupowanie klocków}
W~pierwszym etapie następuje stworzenie podzbiorów klocków zestawu, w
których następnie będą zamieszczane klocki z~identycznym kształtem.

Z~zestawu bierzemy kolejno klocki. Każdy wzięty klocek porównujemy
z~przedstawicielami różnych grup (z~każdej grupy po jednym). Dzięki
ustalonemu wymogowi poprawności zapisu klocka na wejściu (w~rozdziale
\ref{sec:zapis}) porównanie jest wygodne i~intuicyjne. Jeśli dany klocek
jest identyczny z~reprezentantem pewnej grupy, to jest zapisywany do niej.
Jeśli nie jest identyczny z~żadnym reprezentantem, to jest tworzona nowa
grupa i~on staje się jej reprezentantem (przedstawicielem). Etap się
kończy, gdy wszystkie klocki będą przypisane do grup. Najprostszą
i~najbardziej intuicyjną strukturą do zapisania takich powiązań będzie
tablica tablic identyfikatorów\footnote{tu: liczb całkowitych} klocków.
Złożoność obliczeniowa jest równa $O(n^2)$, gdzie $n$ jest proporcjonalna
do liczby klocków w~zestawie.

\subsubsection{Etap 2. Sprawdzenie kilku wybranych proporcji}
Mając pogrupowane klocki, dobieramy określone proporcje z~grup
najbardziej licznych. Proporcją nazywamy podzbiór zestawu klocków.
Pierwszą proporcją jest podzbiór, w~którym znajduje się po jednym
z~klocków z~grup zawierających co najmniej 2 elementy. Jeśli z~danego
,,podzestawu'' uda się ułożyć prostopadłościan, to jego rozwiązanie
wraz z~wynikiem jest zapisywane w~specjalnej tablicy. Następnie określana
jest kolejna proporcja. 1. sposób dobierania kolejnych proporcji przebiega
poprzez dodanie jednego elementu z~grupy, w~której jest największa
nadwyżka. Nadwyżkę definiujemy jako liczbę niewykorzystanych klocków danej
grupy przy klonowaniu. Chociaż klonowanie będzie dopiero w~następnym
kroku, to nie jest ono potrzebne do wyliczenia nadwyżki. Jeśli największa
nadwyżka występuje w~kilku grupach, to klocek jest wybierany
z~najliczniejszej grupy. Jeśli najliczniejszych grup jest kilka, to
z~pierwszej z~nich. 2. sposobem jest odrzucenie grupy najmniej licznej.
Jeśli jest ich kilka, to pierwszej z~nich. Po odrzuceniu następuje pobranie
z~każdej nieodrzuconej grupy po 1 elemencie, czyli zaczęcie na nowo, ale
bez klocków z~odrzuconej grupy.

2. sposób jest wybierany, gdy co najmniej
$90\%$ klocków z~najliczniejszej grupy nie jest wykorzystywana.
Liczba wykorzystanych klocków z~danej grupy jest zdefiniowana jako iloczyn
liczby klocków tej grupy z~proporcji i~liczby kopii proporcji (włącznie
z~daną proporcją). Kopią jest wykorzystanie klocków z~danych grup z~taką
samą proporcją jak wzorcowa przy wykorzystaniu klocków nieużytych. 

Wyjaśnione zostało pojęcie ,,wybrane'' w~nazwie etapu. Słowo ,,kilka''
należy interpretować jako liczbę 10. Czyli w~niniejszym etapie wybieramy
10 etapów. Przedstawione sposoby mówią o~jak najmniej licznych podzbiorach,
z~których ułożenie prostopadłościanu jest najszybsze, zakładając, że się
da ułożyć z~nich prostopadłościan.

\subsubsection{Etap 3. Wybranie optymalnego i~klonowanie}
Dzięki cesze podanej pod koniec poprzedniego\ldots

\subsection{Algorytm Andrzeja}

\section{Struktury danych}

\subsection{Zestaw klocków}
Zestaw klocków jest daną wejściową naszego programu. Niniejszy rozdział
dzieli się na dwie części.

\subsubsection{Format XML}\label{sec:zapis}
Zestaw klocków jest zapisywany w dokumencie XML, którego korzeniem jest
$bricks$. W korzeniu występują jedynie elementy $brick$. Każdy element
$brick$ jest opisem dokładnie jednego klocka. Każdy klocek należący do
zestawu i tylko taki klocek jest opisany za pomocą elementu $brick$.
Element $brick$ zawiera elementy $cube$. Każdy element $cube$ ma podane
wartości trzech atrybutów: $x$, $y$ i $z$.

Podobnie każdy klocek składa się
z sześcianów, które są niepodzielne. Sześcianem jest najmniejszy możliwy
klocek o długości krawędzi równej $1$. Z tego wynika, że krawędzie klocków
mają wartości całkowite równe co najmniej $1$. Każdy sześcian danego
klocka możemy zidentyfikować za pomocą trzech współrzędnych.

Klocek jest
umieszczany w układzie współrzędnych. Dzięki takiemu zabiegowi każde dwa
różne sześciany danego klocka mają różne wektory pomieszczenia. Wektorem
pomieszczenia sześcianu nazywamy wektor złożony z trzech współrzędnych
określających położenie sześcianu względem początku układu. Każdy
sześcian klocka i tylko taki sześcian jest opisany przez element $cube$
zawarty w $brick$ danego klocka.

Sposób na zapis danego klocka, a dokładnie -- jego sześcianów, jest ściśle
określony. Do metody zapisu potrzebna będzie definicja wagi zapisu klocka.
Wagą zapisu klocka nazywamy wartość:
\begin{equation}
	w(k) = \sum_{i=1}^n \rho (s_i)
\end{equation}
gdzie:
$k$ -- klocek,
$n$ -- liczba sześcianów klocka,
$s_i$ -- $i$--ty sześcian klocka,
$\rho (s)$ -- metryka euklidesowa wektora pomieszczenia sześcianu $s$.
Przyda się również definicja wagi zapisu klocka względem współrzędnej
$X_i$:
\begin{equation}
	w_i(k) = \sum_{j=1}^n s_j^i
\end{equation}
gdzie:
$k$ -- klocek,
$n$ -- liczba sześcianów klocka,
$s_j^i$ -- $i$--ta współrzędna $j$--tego sześcianu klocka.

Zapis klocka musi spełniać następujące warunki:
\begin{enumerate}
	\item każdy sześcian klocka ma współrzędne nieujemne,
	\item nie istnieje inny zapis klocka spełniającego warunek 1, którego
		waga jest mniejsza,
	\item waga zapisu względem współrzędnej $X_3=Z$ jest nie mniejsza niż 
		względem współrzędnej $X_2=Y$,
	\item waga zapisu względem współrzędnej $X_2=Z$ jest nie mniejsza niż 
		względem współrzędnej $X_1=Y$,
	\item sześciany mają ustalony porządek:
		\begin{enumerate}
			\item sześcian występujący przed innym w porządku ma nie wyższą
				pierwszą współrzędną,
			\item sześcian występujący przed innym o tej samej wartości
				pierwszej współrzędnej ma nie wyższą drugą współrzędną,
			\item sześcian występujący przed innym o tych samych wartościach
				pierwszej i drugiej współrzędnej ma niższą trzecią współrzędną.
		\end{enumerate}
\end{enumerate}
Ten zapis \textbf{gwarantuje}, że sprawdzenie, czy dwa klocki mają
identyczny kształt, sprowadza się do porównania współrzędnych kolejnych
sześcianów obu klocków. Jest to najszybsza i najwygodniejsza metoda
porównania, czy klocki są identyczne. Przez identyczne należy rozumieć,
że w rozwiązaniu klocek może zostać zastąpiony przez identyczny.

\subsubsection{Struktura danych}
Dane z dokumentu XML, czyli zestaw klocków, będą przechowywane w programie
w postaci listy obiektów klasy $Brick$. Klasa $Brick$ będzie zawierała
listę obiektów klasy $Cube$ odpowiadających sześcianom klocka z dokumentu
XML z zachowaniem kolejności\footnote{patrz: koniec poprzedniego
podrozdziału}.

Kolejność klocków z dokumentu XML będzie zachowana w liście obiektów klasy
$Brick$. Przy sekwencji ruchów będzie potrzebna identyfikacja klocków.
Klockom przypisze się jako identyfikator numer na liście zaczynając od $1$.
Jednak ten identyfikator nie jest potrzebny jako osobne pole w klasie
$Brick$.

\subsection{Sekwencja ruchów}
Sama sekwencja ruchów jest opisana za pomocą ciągu elementów. Elementem
nazywamy:
\begin{equation}
	e_i = (a_i,v,d,o)
\end{equation}
gdzie
$e_i$ -- $i$--ty element w ciągu,
$a_i$ -- indeks klocka użytego jako $i$--ty do konstrukcji sześcianu,
$d$ -- kierunek dokładania klocka,
$v$ -- wektor przemieszczenia klocka,
$o$ -- macierz obrotu.
Kierunkiem dokładania klocka może być $X$, $Y$ lub $Z$. Kierunek dokładania
jest związany z osią układu współrzędnych w przestrzeni 3D. Dokładany
klocek jest dokładany wzdłuż dodatniej półosi danej osi. Klocek zostaje
zatrzymany w dwóch przypadkach, gdy:
\begin{itemize}
	\item dochodzi do zetknięcia z powierzchnią innego klocka i kolejne
		przesunięcie o $1$ wzdłuż osi spowoduje najście na siebie co najmniej 
		jednego sześcianu z powstającego prostopadłościanu i co najmniej
		jednego sześcianu z dokładanego klocka,
	\item dochodzi do zetknięcia z płaszczyzną dwóch pozostałych osi.
\end{itemize}
Punkt, od którego zaczynamy przesuwanie klocka w kierunku powstającego
prostopadłościanu, nie jest istotny. Ważne jest jedynie przesunięcie
klocka względem dwóch pozostałych osi. Takim przesunięciem jest wektor
przemieszczenia, którego pierwsza współrzędna odpowiada przesunięciu
względem osi występującej wcześniej w zadanej kolejności osi układu.
Pozostała, druga współrzędna odpowiada przesunięciu względem pozostałej
osi. Mając podany kierunek tj. wzdłuż której osi dokładamy, wiemy,
jakim osiom odpowiadają dwie współrzędne wektora przemieszczenia klocka.

Przy macierzy obrotu należy pamiętać, że obrót wokół osi może wynosić
0 stopni, 90 stopni bądź wielokrotność 90 stopni.

\subsubsection{Struktura sekwencji ruchu}
Podaną wyżej definicję elementu przenosimy do klasy $Move$. Sekwencja
ruchów jest listą obiektów klasy $Move$. Wszelkie składowe elementu
odwzorujemy jako składowe klasy $Move$.

\subsubsection{Format XML}
Sekwencja ruchów jest zapisywana w dokumencie XML z korzeniem $moves$.
Obiekt klasy $Move$ z listy jest zapisywany do elementu $move$. W korzeniu
są jedynie zawarte te elementy $move$. Element $move$ zawiera po jednym
elemencie:
\begin{itemize}
	\item $brick_id$ -- identyfikator klocka,
	\item $vector$ -- wektor przemieszczenia klocka, gdzie jego współrzędne
		są kolejno opisane przez atrybuty $x1$ i $x2$,
	\item $d$ -- kierunek dokładania klocka, gdzie jedynym atrybutem
		jest wartość ze zbioru $P = {X,Y,Z}$,
	\item $o$ -- macierz obrotu opisana \ldots
\end{itemize}

\end{document}
